# Implementation Plan: Multi-tenant Markdown Notes

**Branch**: `001-multi-tenant-notes` | **Date**: 2026-01-01 | **Spec**: specs/001-multi-tenant-notes/spec.md

## Summary

Implement a production-grade, multi-tenant note service with strict tenant isolation, secure auth, CRUD for Markdown notes, tagging, full-text search, sharing with permission control, and immutable audit logging. Architecture will prioritize async processing for indexing and background tasks, idempotent APIs, and observability.

## Technical Context (environment-constrained)

- Environment: Local machine development, Docker (Compose), Redis, Supabase free tier (PostgreSQL with RLS). No infra budget for managed Kafka/OpenSearch/Kubernetes.
- Language: TBD (recommend: Go / Rust / or Python + FastAPI)
- Primary Dependencies: PostgreSQL (Supabase free) with Row-Level Security (RLS), Redis (caching + lightweight queue via Redis lists/streams), local Job runner (worker process) coordinated via Redis.
- Search: PostgreSQL Full-Text Search (FTS) with async indexing jobs. OpenSearch/Elasticsearch replaced by Postgres FTS due to budget/environment constraints.
- Message broker: Replace Kafka/RabbitMQ with Redis-backed queues (Redis Streams or RQ) for background tasks and eventual consistency.
- Orchestration: Docker Compose for local development and simple deployments; K8s is out of scope for now.
- Storage strategy: Shared schema with mandatory `tenant_id` + enforced RLS policies in Postgres (preferred for Supabase free tier). DB-per-tenant is not used.
- Testing: unit, integration, contract tests; include automated checks for RLS policies and tenant-scoped queries.
- Performance Goals: support thousands of concurrent users when deployed on appropriately sized hosts — design for horizontal scaling within Docker/VM boundaries; rely on async workers for heavy tasks (indexing).

## Constitution Check

Gates (must pass):
- Multi-tenant design is mandatory.
- Shared schema is acceptable only with enforced `tenant_id` constraints + Postgres RLS; document RLS policies and include automated verification tests.
- Security prioritized over feature delivery.

## Project Structure (suggested)

backend/
  ├─ api/
  ├─ services/
  ├─ models/
  └─ jobs/

frontend/
  ├─ static/ (no heavy framework by default)
  └─ widgets/

infra/
  ├─ docker-compose/
  └─ monitoring/

## Phase 0 (Research)

1. Confirm RLS policies and tenant model for Supabase free (shared schema + `tenant_id`).  
2. Define Postgres FTS schema and async indexing plan (materialized tsvector column + background worker).  
3. Define Redis-backed queue approach for background jobs and idempotency key handling.  
4. Define audit log storage pattern (append-only table, retention, access controls).

## Phase 1 (Design)

1. Data model and contracts (notes, shares/ACLs, audit logs) optimized for shared-schema + RLS.
2. API design with idempotency (Idempotency-Key support) and secure session handling (no localStorage for tokens; use HttpOnly cookies).
3. Background jobs: Redis-backed indexing, notifications, cleanup; design worker restart and at-least-once handling with idempotency.

4. Devops: Docker Compose configuration for app, worker, Redis, and local Supabase/Postgres (or remote Supabase connection).

## Phase 2 (Implementation)

1. Auth + user management (integrate Supabase Auth or implement JWT with HttpOnly cookies).  
2. Note CRUD + ACL enforcement with RLS policies and contract tests.  
3. Tagging + Postgres FTS integration (background indexing via Redis workers).  
4. Audit logging (append-only Postgres table with `tenant_id`, `user_id`, `action`, `request_id`).  
5. Docker Compose setup and developer quickstart.

## Deliverables

- `specs/001-multi-tenant-notes/spec.md`  
- `specs/001-multi-tenant-notes/plan.md`  
- tasks.md (to be generated by `/speckit.tasks`)
